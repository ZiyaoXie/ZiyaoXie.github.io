<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sqlite on 提笔忘字</title><link>https://imx.ink/sqlite/</link><description>Recent content in Sqlite on 提笔忘字</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>Copyright © 2023, Xie Ziyao.</copyright><lastBuildDate>Wed, 26 Jul 2023 14:36:00 +0800</lastBuildDate><atom:link href="https://imx.ink/sqlite/index.xml" rel="self" type="application/rss+xml"/><item><title>解决 SQLite 并发异常问题的方法</title><link>https://imx.ink/tech/2023/07/26/sqlite-concurrency-exception/</link><pubDate>Wed, 26 Jul 2023 14:36:00 +0800</pubDate><guid>https://imx.ink/tech/2023/07/26/sqlite-concurrency-exception/</guid><description>SQLite 是文件级别的数据库，其锁也是文件级别的：多个进程/线程可以同时读，但是同时只能有一个进程/线程写。
问题描述 在执行写操作时，数据库文件被琐定，此时任何其他读/写操作都被阻塞，如果阻塞超过5秒钟（默认是5秒，能过重新编译 SQLite 可以修改超时时间），就报&amp;quot;database is locked&amp;quot;错误。
解决方法 1、连接数据库时设置参数 timeout，设置当数据库处于锁定状态时最长等待时间，sqlite3.connect()函数的参数 timeout 默认值为 5 秒，不适合服务端程序；
2、使用锁机制使得多个进程/线程竞争进入临界区，确保同一时刻只有一个进程/线程执行写入数据库的代码；
# 以多进程写为例, 注释 lock.acquire() 和 lock.release() 可复现问题 #!/usr/bin/env python3 # -*- coding: utf-8 -*- # @Time : 2023/7/24 10:38 # @Author : ziyaoxie # @File : write_sqlite_with_multiprocessing.py import sqlite3 import traceback import multiprocessing from contextlib import closing def prepare_db(db, tbl, col): sql = &amp;#34;CREATE TABLE {0} ({1} text);&amp;#34;.format(tbl, col) with closing(sqlite3.connect(db)) as cnn: cursor = cnn.</description></item></channel></rss>